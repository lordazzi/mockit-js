<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='MockitJs'>/**
</span> * @author Ricardo Azzi Silva &lt;ricardoazzi91@hotmail.com&gt;
 * @version  v2.0.6
 * @class MockitJs
 * @singleton
 *
 * @uses MockitJs.IO
 * @uses MockitJs.XMLHttpRequest
 * @uses MockitJs.httpReader
 * @uses MockitJs.mockReader
 * @uses MockitJs.FormDataReader
 * @uses MockitJs.FormData
 *
 * Um protótipo genérico javascript, criado com o objetivo de mockar as
 * requisições http e controlar o uso deste mock
 */
window.MockitJs = new function(){

	//	singlentando...
	if (arguments.callee._singletonInstance)
    	return arguments.callee._singletonInstance;
    var me			= arguments.callee._singletonInstance = this;
    var openAlias	= [];
    me.version = 'v2.0.6';

<span id='MockitJs-method-generateFileName'>	/**
</span>	 * Gera um nome para o arquivo que será salvo, caso ele seja um novo
	 * arquivo
	 *
	 * @private
	 * 
	 * @return {String}
	 * Nome gerado dinâmicamente
	 */
	var generateFileName = function(){
		var date = new Date();
		var d = date.getDate();
		d = d &lt; 9 ? &quot;0&quot;+d : String(d);

		var m = date.getMonth() + 1;
		m = m &lt; 9 ? &quot;0&quot;+m : String(m);

		var Y = date.getFullYear();

		var H = date.getHours();
		H = H &lt; 9 ? &quot;0&quot;+H : String(H);

		var i = date.getMinutes();
		i = i &lt; 9 ? &quot;0&quot;+i : String(i);

		var fileName = &quot;mockitjs - &quot;+d+&quot;-&quot;+m+&quot;-&quot;+Y+&quot; &quot;+H+&quot;-&quot;+i+&quot;.json&quot;;

		return fileName;
	};

<span id='MockitJs-method-record'>	/**
</span>	 * @method record
	 * Inicia a captura das requisições http
	 */
	me.record = function(){
		window.XMLHttpRequest = MockitJs.httpReader;
		window.FormData = MockitJs.FormDataReader;
	};

<span id='MockitJs-method-stopRecording'>	/**
</span>	 * @method stopRecording
	 * Para a captura das requisições http
	 */
	me.stopRecording = function(){
		window.XMLHttpRequest = MockitJs.XMLHttpRequest;
		window.FormData = MockitJs.FormData;
	};

<span id='MockitJs-method-stopHttp'>	/**
</span>	 * @method stopHttp
	 * Faz com que a página pare de ler as requisições
	 * http e leia somente as informações do mock, é importante
	 * lembrar que nada dentro da página será capaz de efetuar
	 * requisições http enquanto a leitura por mock estiver
	 * habilitada
	 */
	me.stopHttp = function(){
		openAlias				= [];
		window.XMLHttpRequest	= MockitJs.mockReader;
	};

<span id='MockitJs-method-playHttp'>	/**
</span>	 * @method playHttp
	 * Para de ler as informações do mock e volta a fazer
	 * as requisições http normalmente
	 */
	me.playHttp = function(){
		openAlias				= [];
		window.XMLHttpRequest = MockitJs.XMLHttpRequest;
	};

<span id='MockitJs-method-loadFromHttp'>	/**
</span>	 * @method loadFromHttp
	 * Faz a chamada de uma requisição http para abrir o arquivo de mock,
	 * este método é utilizado para quando o mock precisa ser lido para o
	 * uso deles nos testes
	 *
	 * @param {String} path
	 * Localização do arquivo de mock
	 * 
	 * @param {Function} callback
	 * Função executada quando o arquivo já foi enviado e o mock
	 * setado
	 * 	@param {Boolean|Error} callback.hasError
	 * 	Retorna um objeto de erro caso não tenha sido possível ler
	 * 	o arquivo, caso contrário retorna false
	 */
	me.loadFromHttp = function(path, calle){
		var xhr = new MockitJs.XMLHttpRequest;
		xhr.open('GET', path, true);
		xhr.onreadystatechange = function(){
			if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
				var name = path.match(/[^\/]+$/);
				var isOpen = MockitJs.IO.declareFileOpen(
					name, xhr.responseText
				);
				if (calle &amp;&amp; calle.constructor == Function) { calle(isOpen); }
			}
		};

		xhr.send();
	};

<span id='MockitJs-method-loadFromDialog'>	/**
</span>	 * @method loadFromDialog
	 * Evoca um open file dialog do sistema para que o usuário
	 * entregue ao MockitJs um arquivo com mock salvo
	 *
	 * @param {Function} callback
	 * Função executada quando o arquivo já foi enviado e o mock
	 * setado
	 * 	@param {Boolean|Error} callback.hasError
	 * 	Retorna um objeto de erro caso não tenha sido possível ler
	 * 	o arquivo, caso contrário retorna false
	 */
	me.loadFromDialog = function(calle){
		setTimeout(function(){
			var i = document.createElement('input');
			i.setAttribute('type', 'file');

			i.addEventListener('change', function(){
				var file = this.files[0];
				var fr = new FileReader();
				fr.onload = function(){
					var isOpen = MockitJs.IO.declareFileOpen(
						file.name, fr.result
					);

					if (calle &amp;&amp; calle.constructor == Function) { calle(isOpen); }
					delete i;
				};
				fr.readAsText(file);
			}, false);

			document.body.appendChild(i);
			i.click();
			document.body.removeChild(i);
		}, 0);
	};

<span id='MockitJs-method-save'>	/**
</span>	 * @method save
	 * Cria um arquivo com o mock gerado e baixa para a maquina
	 * do usuário
	 */
	me.save = function(){
		setTimeout(function(){
			var file = MockitJs.IO.getFile();
			if (!file.name) { file.name = generateFileName(); }

			//	cria o blob
			var blob = new Blob(
					[ file.content ], { type: 'text/plain' }
				);
			//	cria um link virtual
			var a = document.createElement('a');
			a.setAttribute('href', URL.createObjectURL(blob));
			a.setAttribute('target', '_blank');
			a.setAttribute('download', file.name);
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			delete a;
		}, 0);
	};

<span id='MockitJs-method-clear'>	/**
</span>	 * @method clear
	 * Limpa o mock no browser
	 */
	me.clear = function(){
		MockitJs.IO.clear();
	};

<span id='MockitJs-method-setAliasListener'>	/**
</span>	 * @method setAliasListener
	 * Antes da requisição http ser enviada para o servidor,
	 * ele chama o método {@link #getAliasListener}, para
	 * retornar uma função que, executando-a, irá dizer qual
	 * será o alias do próximo parâmetro a ser enviado para o
	 * servidor.
	 *
	 * O real proposito da criação deste método é a integração
	 * do MockitJs com o seu GUI 
	 * 
	 * @param {Function} calle
	 * Função chamada antes de cada requisição http
	 *
	 * @param {String} calle.url
	 * Url da requisição a ser apelidada
	 * 
	 * @param {String} calle.method
	 * Método da requisição a ser apelidada
	 *
	 * @return {Boolean}
	 * Se a chamada foi setada ou não
	 *
	 * @private
	 */
	me.setAliasListener = function(calle){
		var me = this;
		if (typeof calle == 'function') {
			aliasListener = calle;
			return true;
		}

		return false;
	};

<span id='MockitJs-method-getAliasListener'>	/**
</span>	 * @method getAliasListener
	 * Retorna a função setada externamente que entrega o alias
	 * que será dado ao parâmetro
	 * 
	 * @return {String}
	 * Alias da próxima requisição
	 *
	 * @private
	 */
	me.getAliasListener = function(){
		return aliasListener;
	};

<span id='MockitJs-method-openAlias'>	/**
</span>	 * @method openAlias
	 * Quando você precisa de um retorno simulado do arquivo de mock, mas
	 * não sabe se os parâmetros estarão de acordo com sua necessidade,
	 * você pode forçar um retorno de dados dando apelidos aos parâmetros
	 * de envio.
	 *
	 * Basicamente você da apelidos simples aos dados complexos que são enviados
	 * ao servidor e, quando o Mockit detectar que você está com este apelido
	 * em aberto, ele vai enviar os dados relacionados a este apelido ao invés
	 * dos dados que foram passados para a requisição http.
	 *
	 * Cada alias é vinculado com um url/método.
	 *
	 * Com este método você pode dizer ao Mockit qual alias você deseja manter
	 * aberto.
	 *
	 * Você só pode abrir alias enquanto o Mockit estiver no modo de leitura
	 * no mock, se você tentar abrir em uma situação diferente, apenas não
	 * acontecerá nada.
	 *
	 * @param {String|String[]} alias
	 * Qual/Quais alias você deseja abrir
	 */
	me.openAlias = function(alias){
		if (alias &amp;&amp; alias.constructor === Array) {
			openAlias = openAlias.concat(alias);
		} else if (alias &amp;&amp; alias.constructor === String) {
			openAlias.push(alias);
		}
	};

<span id='MockitJs-method-closeAlias'>	/**
</span>	 * @method closeAlias
	 * Fecha um alias aberto
	 * 
	 * @param  {String|String[]} alias
	 * Qual/Quais alias você deseja encerrar
	 */
	me.closeAlias = function(alias){
		for (var i = 0; i &lt; openAlias.length; i++) {
			if (openAlias[i] == alias) {
				openAlias.splice(i, 1);
				i--;
			}
		}
	};

<span id='MockitJs-method-isAliasOpen'>	/**
</span>	 * @method isAliasOpen
	 * Verifica se um alias está aberto
	 *
	 * @param {String} alias
	 * Nome do alias que você deseja verificar se está aberto
	 * 
	 * @return {Boolean}
	 * Resposta se o alias está aberto
	 */
	me.isAliasOpen = function(alias){
		return (openAlias.indexOf(alias) !== -1);
	};

<span id='MockitJs-method-readParamAlias'>	/**
</span>	 * @method readParamAlias
	 * Buscas os parâmetros de uma requisição através de
	 * sua url, método e apelido
	 *
	 * @params {Object} args
	 * Objeto com os argumentos que devem ser enviados para
	 * recuperar os parâmetros
	 * 
	 * @param  {String} args.url
	 * Url da requisição
	 * 
	 * @param  {String} [args.method='GET']
	 * Método http da requisição
	 * 
	 * @param  {String} args.alias
	 * Apelido dado para os dados enviados na requisição
	 * 
	 * @return {String}
	 * Dados enviados na requisição guardada
	 */
	me.readParamAlias = function(args){
		return MockitJs.IO.readParamAlias(args);
	};
};

<span id='MockitJs-property-cacheVarName'>/**
</span> * @property
 * @type {String}
 *
 * Algumas aplicações enviam um parâmetro para requisições http
 * para quebrar cache de arquivo, isso atrapalha o MockitJs (:
 *
 * Se sua aplicação fizer isso, você precisa definir nesta
 * propriedade o nome do parâmetro get de remoção de cache
 */
MockitJs.cacheVarName = '';

<span id='MockitJs-property-syncronizeApp'>/**
</span> * @property
 * @type {Boolean}
 *
 * Força toda a aplicação trabalhar de forma sincrona (pelo menos
 * ao que se refere a requisições http)
 */
MockitJs.syncronizeApp = false;

<span id='MockitJs-IO'>/**
</span> * @class MockitJs.IO
 * Classe responsável pela manipulação do arquivo de mock
 *
 * @private
 */
MockitJs.IO = new function(){
	//	singlentando...
	if (arguments.callee._singletonInstance)
    	return arguments.callee._singletonInstance;
    var me = arguments.callee._singletonInstance = this;
    var aliasListener = function(){};

<span id='MockitJs-IO-method-declareFileOpen'>	/**
</span>	 * Método responsável por definir o arquivo como aberto
	 * 
	 * @param  {String} name
	 * Nome do arquivo que será definido como aberto
	 * 
	 * @param  {String} content
	 * Conteúdo do arquivo
	 * 
	 * @return {Error|Boolean}
	 * Se o conteúdo do arquivo conter erros, então o objeto de
	 * erro é devolvido, caso contrário se retorna false
	 */
	me.declareFileOpen = function(name, content){
		try {
			JSON.parse(content);
		} catch (e) {
			return e;
		}

		localStorage.mockitjs_filecontent	= content;
		localStorage.mockitjs_filename		= name;

		return false;
	};

<span id='MockitJs-IO-method-feedFile'>	/**
</span>	 * Alimenta o arquivo aberto com mais informações de mock
	 *
	 * @param {Object} args
	 * Parâmetros necessários para salvar uma entrada e saída no mock
	 * 
	 * @param  {String} args.url
	 * Url para qual a requisição http foi direcionada
	 *
	 * @param {String} [args.method=&quot;GET&quot;]
	 * Método http que a requisição foi chamada (GET, POST, PUT, DELETE)
	 * 
	 * @param {String} [args.params=&quot;null&quot;]
	 * Parâmetro que estão sendo enviados para o servidor
	 *
	 * @param {String} [paramAlias=false]
	 * Apelido que será dado para os parâmetros da requisição
	 *
	 * @param {String} [response='']
	 * Resposta da requisição
	 */
	me.feedFile = function(args){
		if (!args) { args = {}; }
		if (!args.url) { throw &quot;Impossível registrar um mock sem a url de envio da requisição.&quot;; }
		if (!args.method) { args.method = 'GET'; }
		if (!args.params) { args.params = 'null'; }
		if (!args.paramAlias) { args.paramAlias = false; }
		if (!args.response) { args.response = ''; }

		//	método da requisição http sempre em uppercase
		args.method = String(args.method).toUpperCase();

		//	local onde deveria estar o arquivo está vazio?
		//	O método clear coloca um objeto
		if (!localStorage.mockitjs_filecontent) { me.clear(); }

		//	lê o conteúdo do arquivo aberto
		var mock	= JSON.parse(localStorage.mockitjs_filecontent);

		///
		if (!mock[args.url])
			mock[args.url] = {};

		if (!mock[args.url][args.method])
			mock[args.url][args.method] = {};

		if (args.paramAlias) {
			var aliasKey = args.method+'-alias';
			if (!mock[args.url][aliasKey])
				mock[args.url][aliasKey] = {};

			mock[args.url][aliasKey][args.paramAlias] = args.params;
		}

		//	alterando o arquivo
		mock[args.url][args.method][args.params] = args.response;

		//	salvando o arquivo
		localStorage.mockitjs_filecontent = JSON.stringify(mock);
	};

<span id='MockitJs-IO-method-readParamAlias'>	/**
</span>	 * @method readParamAlias
	 * Buscas os parâmetros de uma requisição através de
	 * sua url, método e apelido
	 *
	 * @params {Object} args
	 * Objeto com os argumentos que devem ser enviados para
	 * recuperar os parâmetros
	 * 
	 * @param  {String} args.url
	 * Url da requisição
	 * 
	 * @param  {String} [args.method='GET']
	 * Método http da requisição
	 * 
	 * @param  {String} args.alias
	 * Apelido dado para os dados enviados na requisição
	 * 
	 * @return {String}
	 * Dados enviados na requisição guardada
	 */
	me.readParamAlias = function(args){
		if (!args) { args = {}; }
		if (!args.url) { throw &quot;Impossível ler alias sem a url&quot;; }
		if (!args.method) { args.method = 'GET'; }
		if (!args.alias) { throw &quot;Impossível ler alias sem o alias&quot;; }

		var mock	= JSON.parse(localStorage.mockitjs_filecontent);
		var data	= mock[args.url];
		if (!data) { return 'null'; }
		data		= data[args.method+'-alias'];
		if (!data) { return 'null'; }

		return data[args.alias] || 'null';
	};

<span id='MockitJs-IO-method-readFile'>	/**
</span>	 * @method readFile
	 * Retorna o conteúdo do arquivo se baseando na url, no método http
	 * e nos parâmetros que foram enviados, se a url unida com o método
	 * http não forem encontrados no mock, o método gera um warning, se
	 * os parâmetros para aquela url não forem encontrados, ele irá retornar
	 * os registros do primeiro indice dentro da chave formada pela url e
	 * pelo método http.
	 * 
	 * @param  {String} url
	 * Url da requisição http
	 * 
	 * @param  {String} method
	 * Método http da requisição
	 * 
	 * @param  {String} [params]
	 * Dados que foram enviados para o servidor
	 * 
	 * @return {String}
	 * Dados de retorno da requisição que estão guardados no mock
	 */
	me.readFile = function(url, method, params){
		method		= String(method).toUpperCase();
		params		= params || '';

		var mock	= JSON.parse(localStorage.mockitjs_filecontent);
		var data	= mock[url] || {};
		var vazio	= '{}';
		data		= data[method] || {};

		//	verificando se existe algo dentro da url[metodo]
		if (!data) {
			console.warn('Tentando ler informações de uma url/método que nunca foram mocados! '+url+' sobre '+method);
			return vazio;
		}

		//	verificando se existe um alias em aberto, para sobrescrever os dados enviados
		var aliasses = data[method+&quot;-alias&quot;];
		for (var alias in aliasses) {
			if (MockitJs.isAliasOpen(alias)) {
				params = aliasses[alias];
			}
		}

		//	se não existir nada mocado nesta posição,
		//	então retorna o conteúdo da primeir posição
		if (!data[params]) {
			for (var key in data) {
				data = data[key];
				break;
			}
		} else {
			data = data[params];
		}

		//	se não encontrar nada, retorna um json vazio
		return data || vazio;
	};

<span id='MockitJs-IO-method-getFile'>	/**
</span>	 * Retorna um objeto com o nome do arquivo e o seu conteúdo
	 *
	 * @private
	 * 
	 * @return {Object}
	 * Objeto com o nome do arquivo e seu conteúdo
	 *
	 * #name
	 * Nome do arquivo
	 *
	 * #content
	 * Conteúdo do arquivo
	 */
	me.getFile = function(){
		return {
			name:		localStorage.mockitjs_filename,
			content:	localStorage.mockitjs_filecontent
		};
	};

<span id='MockitJs-IO-method-clear'>	/**
</span>	 * @method clear
	 * Limpa o mock no browser
	 */
	me.clear = function(){
		localStorage.mockitjs_filecontent = '{}';
		localStorage.mockitjs_filename = '';
	};

<span id='MockitJs-IO-method-hasFile'>	/**
</span>	 * @method hasFile
	 * Verifica se há um arquivo aberto
	 *
	 * @return {Boolean}
	 */
	me.hasFile = function(){
		return (
			localStorage.mockitjs_filecontent != '{}' &amp;&amp;
			localStorage.mockitjs_filecontent != '' &amp;&amp;
			localStorage.mockitjs_filecontent != undefined
		);
	};
};

<span id='send'>/**
</span> * @class MockitJs.XMLHttpRequest
 * Classe nativa que trata as requisições http do javascript
 *
 * @method send
 * Envia informações para o servidor
 *
 * @param {String|Object|Node|Blob|MockitJs.FormData} json
 * Informações que serão enviadas para o servidor
 *
 * @private
 */
MockitJs.XMLHttpRequest = window.XMLHttpRequest;

<span id='append'>/**
</span> * @class MockitJs.FormData
 * Classe nativa de armazenamento de dados do javascript
 *
 * @method append
 * Vincula um novo valor à instância de FormData
 *
 * @param {String} name
 * Nome do atributo
 *
 * @param {Boolean|String|Number|null|undefined|Blob} value
 * Valor vinculado ao atributo
 *
 * @param {String} [filename]
 * Se o valor anterior for do tipo Blob, o terceiro parâmetro
 * será o nome do arquivo contido no Blob
 *
 * @private
 */
MockitJs.FormData = window.FormData;

<span id='FormDataReader'>/**
</span> * @class FormDataReader
 * Enquanto a aplicação está escutando as requisições http,
 * este protótipo deve substituir {@link MockitJs.FormData}
 * enquanto {@link MockitJs.httpReader} estiver substituindo
 * {@link MockitJs.XMLHttpRequest}
 *
 * @extends {MockitJs.FormData}
 * 
 * @private
 */
MockitJs.FormDataReader = function FormData() {
	var me = new MockitJs.FormData;
	var append = me.append;
	var json = {};
	me.append = function(name, value){
		json[name] = value;
		append.apply(me, arguments);
	};

	me.toString = function(){
		return JSON.stringify(json);
	};

	return me;
};

<span id='MockitJs-httpReader'>/**
</span> * @class MockitJs.httpReader
 *
 * Classe responsável por sobrescrever o
 * {@link MockitJs.XMLHttpRequest protótipo de operação io http nativo}
 * do javascript, ele mantém todas as funcionalidades do
 * protótipo nativo, mas faz a leitura de cada dado que
 * entra e sai
 *
 * @private
 * 
 * @extends MockitJs.XMLHttpRequest
 */
MockitJs.httpReader = function XMLHttpRequest(){
	var me		= new MockitJs.XMLHttpRequest;
	var alias	= '';

	me.addEventListener(&quot;readystatechange&quot;, function(){ 
		if (me.readyState == 4 &amp;&amp; me.status == 200) {

			//	tirando o parâmetro adicional para remoção de cache
			var url = me.responseURL;
			if (MockitJs.cacheVarName) {
				var reg	= new RegExp('('+MockitJs.cacheVarName+'=).+(&amp;|$)');
				url		= url.replace(reg);
				url		= url.replace(/[?]$/, '');
			}

			//	capturando o alias dos parâmetros que serão enviados
			var _aliasListen = MockitJs.getAliasListener();
			var _alias = alias || (typeof _aliasListen == 'function' ? _aliasListen(url, me.method) : '');

			//	salvando requisição
			MockitJs.IO.feedFile({
				url:		url,
				method:		me.method,
				params:		me.data,
				paramAlias:	_alias,
				response:	me.responseText
			});
		}
	}, false);

<span id='MockitJs-httpReader-method-send'>	/**
</span>	 * @method send
	 * Sobrescreve o método {@link MockitJs.XMLHttpRequest#send send}
	 * de {@link MockitJs.XMLHttpRequest XMLHttpRequest}
	 * para ler os parâmetros que são enviados para o servidor
	 *
	 * @param {String} data
	 * Dados enviados para o servidor
	 */
	var send = me.send;
	me.send = function(data){
		if (!data) {
			data = 'null';
		} else if (data.constructor === Object) {
			data = JSON.stringify(data);
		} else if (data instanceof MockitJs.FormDataReader) {
			data = String(data);
		} else if (data instanceof Node) {
			var parser = new XMLSerializer;
			data = parser.serializeToString(data);
		} else if (data instanceof Blob) {
			data = URL.createObjectURL(data);
		} else {
			data = String(data);
		}
		me.data = data;
		send.apply(this, arguments);
	};

<span id='MockitJs-httpReader-method-open'>	/**
</span>	 * @method open
	 * Sobrescreve o método {@link MockitJs.XMLHttpRequest#send open}
	 * de {@link MockitJs.XMLHttpRequest XMLHttpRequest}
	 * para ler o método que a requisição irá utilizar
	 */
	var open = me.open;
	me.open = function(method){
		me.method = method;
		open.apply(this, arguments);
	};

<span id='MockitJs-httpReader-method-setAlias'>	/**
</span>	 * @method setAlias
	 * Método para setar um apelido nos parâmetros que serão enviados
	 * para o http.
	 *
	 * A utilidade de alias nos parâmetros é para usá-los na aplicação
	 * de teste, pois no lugar de escrever toda a string de parâmetros
	 * que serão enviados para o servidor, você define que o alias está
	 * habilitado e, se aquela url unido com aquele método http tiver
	 * armazenado nela aquele apelido habilitado, ela ignora os parâmetros
	 * que a aplicação esta enviando e assume os parâmetros do alias.
	 *
	 * @param {String} alias
	 * Apelido que será dado aos parâmetros que estão para ser enviados
	 */
	me.setAlias = function(_alias){
		alias = _alias;
	};

	return me;
};

<span id='MockitJs-mockReader'>/**
</span> * @class MockitJs.mockReader
 *
 * Classe responsável por sobrescrever o
 * {@link MockitJs.XMLHttpRequest protótipo de operação io http nativo}
 * do javascript, ele mantém todas as caracteristicas do objeto nativo,
 * porém todas ocas. Ao invés de efetuar as requisições http ele faz a
 * leitura do mock
 *
 * @private
 */
MockitJs.mockReader = function XMLHttpRequest(){
	var me = this;

	var async = true;
	var method = 'GET';
	var headers = {};

	me.DONE = 4;
	me.HEADERS_RECEIVED = 2;
	me.LOADING = 3;
	me.OPENED = 1;
	me.UNSENT = 0;

	me.readyState = 0;
	me.status = 0;

	me.overrideMimeType = 'text/plain';
	me.responseType = '';
	me.statusText = '';
	me.responseXML = '';
	me.responseURL = '';
	me.withCredentials = false;
	me.timeout = 0;

	me.abort = false;
	me.response = '';
	me.responseText = '';

	me.onabort = function(){};
	me.onerror = function(){};
	me.onload = function(){};
	me.onloadend = function(){};
	me.onloadstart = function(){};
	me.onprogress = function(){};
	me.onreadystatechange = function(){};
	me.ontimeout = function(){};

<span id='MockitJs-mockReader-method-simularIO'>	/**
</span>	 * @method simularIO
	 * Faz a leitura do mock se baseando nas informações
	 * passadas para o objeto esperando que ele efetuasse
	 * a operação http
	 * 
	 * @param  {String} params
	 * Valores que serão enviados para o servidor
	 *
	 * @private
	 */
	var simularIO = function(params){
		var data = MockitJs.IO.readFile(me.responseURL, method, params);

		me.response		= data;
		me.responseText	= data;
		me.readyState	= 4;
		me.status		= 200;

		me.onreadystatechange(me);
	};

	me.upload = function(){};

	me.setRequestHeader = function(header, value) {
		headers[header] = value;
		return value;
	};

	me.getAllResponseHeaders = function(){
		if (!headers['Content-Type']) {
			headers['Content-Type'] = me.overrideMimeType;
		}

		var str = '';
		for (var head in headers) {
			str += head+':'+headers[head]+';\n';
		}

		return str;
	};


	me.getResponseHeader = function(header) {
		return headers[header] || '';
	};

	me.open = function(mtd, url, a){
		async			= a;
		method			= mtd;
		me.responseURL	= url;
	};

	me.addEventListener = function(event, call){
		me['on'+event] = call;
	};

	me.send = function(params){
		if (async &amp;&amp; !MockitJs.syncronizeApp) {
			setTimeout(function(){
				simularIO(params);
			}, 0);
		} else {
			simularIO(params);
		}
	};
};</pre>
</body>
</html>
